---
title: 手撕代码
date: 2019-09-17 09:09:51
tags:
---
# 手写bind,call和apply
## 实现一个bind
```
Function.prototype.bind = function(context,...bindArgs){
    //func为调用bind的原函数
    const func = this;
    context = context || window;
    if(typeof func !== 'function'){
        throw new TypeError('Bind must be called on a function');
    }
    //bind返回一个绑定this的函数
    return function(...callArgs){
        let args = bindArgs.concat(callArgs);
        if(this instanceof func){
            //意味着通过new 调用的，而new的优先级高于bind
            return new func(...args);
        }
        return func.call(context,...args);
    }
}
```
## 实现call
```
Function.prototype.call = function(context,...args){
    context = context || window;
    context.func = this;
    if(typeof context.func !== 'function'){
        throw new TypeError('call must be called on a function');
    }
    let res = context.func(...args);
    dalete context.func;
    return res;
}
```
## 实现apply
```
Function.prototype.apply = function(context,args){
    context = context || window;
    context.func = this;
    if(typeof context.func !== 'function'){
        throw new TypeError('apply must be called on a function');
    }
    let res = context.func(...args);
    delete context.func;
    return res;
}
```
# 实现一个继承
```
//基类
function Base(){
}
//派生类
function Derived(){
    Base.call(this);
}
//将派生类的原型的原型链挂在基类的原型上
Object.setPrototypeOf(Derived.prototype,Base.prototype);
```
# 实现一个new 
```
function _new(fun,...args){
    if(typeof fun !== 'function'){
        return new Error('参数必须是一个函数');
    }
    let obj = Object.create(fun.prototype);
    let res = fun.call(obj,...args);
    if(res!==null && (typeof res === 'object' || typeof res === 'function')){
        return res;
    }
    return obj;
}
```
# 实现一个instanceof
```
function _instanceof(a,b){
    while(a){
        if(a.__proto__ === b.prototype) return true;
        a= a.__proto__;
    }
    return false;
}
```
# 手写一个jsop
```
//foo函数将会被调用 传入后台返回数据
function foo(data){
    console.log('通过jsonp获取后台数据',data);
    document.getElementById('data').innerHTML = data;
}

/*
通过手动创建一个script标签发送一个get请求
并利用浏览器对<script>不进行跨域限制的特性绕过跨域问题 
*/
(function jsop(){
    let head = document.getElementsByTagName('head')[0];//获取head元素，把js放里面
    let js = document.createElement('script');
    js.src = 'http://domain:port/testJSONP?a=1&b=2&callback=foo';//设置请求地址
    head.appendChild(js);//发送请求
})();

//后台代码
function testJSOP(callback,a,b){
    return `${callback}(${a+b})`;
}
```
# Ajax的实现
```
function ajax(options){
    var method = options.method || 'GET',
        params = options.params,
        data = options.data,
        url = options.url + (params ? '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&') : ''),
        async = options.async === false ? false : true,
        success = options.success,
        headers = options.headers;

    var request;
    if(window.XMLHttpRequest){
        request = new XMLHttpRequest();
    }else{
        request = new ActiveXObject('Microsoft.XMLHTTP');
    }

    request.onreadystatechange = function(){
        /*
        readyState:
            0：请求未初始化
            1：服务器连接已建立
            2：请求已接收
            3：请求处理中
            4：请求已完成，且响应已就绪
            status:HTTP 状态码
        */
        if(request.readyState === 4 && request.status === 200){
            success && success(request.responseText);
        }
    }
    request.open(method,url,async);
    if(headers){
        Object.keys(headers).forEach(key => request.setRequestHeader(key,headers[key]));
    }
    method === 'GET' ? request.send() : request.send(data);
}

ajax({
    method:'GET',
    url:'...',
    success:function(res){
        console.log('success',res);
    },
    async:true,
    params:{
        p:'test',
        t:666
    },
    headers:{
        'Content-Type':'application/json'
    }

})
```
# reduce的实现
```
  
```
# 实现generator的自动执行器
# 节流
# 防抖
# 手写Promise
# 实现一个路由--Hash
# 路由实现--histoty