#圣杯布局
布局要求：
- 三列布局，中间宽度自适应，两边定宽
- 中间栏要在浏览器中优先展示渲染
- 允许任意列的高度最高

```html
<div class="header">header</div>
<div class="container">
  <div class="main">main</div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
<div class="footer">footer</div>
```
因为需要中间栏优先展示渲染，所以中间的main在HTML的结构中却是最靠前的。在实际的网站中这样做的好处就是用户能够先看到网页正文信息，一般网页两边的导航信息和说明信息我们认为优先级没有正文重要。

1. 设置基本样式
```css
*{margin:0;padding:0;}
body{
  min-width:700px;
}
.header,.footer{
  border:1px solid #333;
  background:#aaa;
  text-align:center;
}
.left,.main,.right{
  min-height:130px;
  float:left;
}
.container{
  border:2px solid yellow;
}
.left{
  width:200px;
  background:red;
}
.right{
  width:220px;
  background:green;
}
.main{
  background:blue;
}
```
为了高度保持一致给left middle right都加上min-height:130px

![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144149281-1239869596.jpg)


2. 将主体部分的三个子元素都设置左浮动
```css
.left,.main,.right{
  float:left;
}
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144219084-985186133.jpg)


我们看一下上面的效果比较明显的两个问题，一是footer跑到上面去了，二是container容器高度塌陷了，这是典型的“清除浮动和闭合浮动”问题。
3. 解决浮动问题
```css
.container{
  border:2px solid yellow;
  overflow:hidden;
}
.footer{
  clear:both;
}
```
给container加上overflow:hidden触发BFC闭合浮动，给footer加上clear属性清除浮动。
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144232920-1725102262.jpg)


我们发现footer移到了下面，并且container的高度塌陷也修复了。
4. 设置main宽度为width:100%,让其独占满一行
.main{
  width:100%;
  background:blue;
}

![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144244328-1499488747.jpg)

5. 设置left和right负的外边距
我们的目标是让left、main、right依次并排，但是上图中left和right都是位于下一行，这里的技巧就是使用负的margin-left:
```
.left{
  margin-left:-100%;
  width:200px;
  background:red;
}
.right{
  margin-left:-220px;
  width:220px;
  background:green;
}
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144255457-752500337.jpg)

负的margin-left会让元素沿文档流向左移动，如果负的数值比较大就会一直移动到上一行。关于负的margin的应用也是博大精深，这里肯定是不能详细介绍了。
设置left部分的margin-left为-100%,就会使left向左移动一整个行的宽度，由于left左边是父元素的边框，所以left继续跳到上一行左移，一直移动到上一行的开头，并覆盖了main部分（仔细观察下图，你会发现main里面的字“main”不见了，因为被left遮住了），left上移过后，right就会处于上一行的开头位置，这是再设置right部分margin-left为负的宽度，right就会左移到上一行的末尾。

![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144317876-696975568.jpg)

6. 修复覆盖问题
第五步我们说过设置left和right负的外边距覆盖了main部分的内容，现在想办法修复这个问题，首先给container的左右加上一个内边距，分别为left和right的宽度。
```
.container{
  border:2px solid yellow;
  padding:0 220px 0 200px;
  overflow:hidden;
}
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144326803-1561906906.jpg)

由于left、main、right三个部分都被container包裹着，所以给其添加内边距，三个子元素会往中间挤。貌似还是没有修复问题，别着急，我们已经在container的左右两边留下了相应宽度的留白，只要把left和right分别移动到这两个留白就可以了。可以使用相对定位移动left和right部分，

```
.left,.main,.right{
  position:relative;
  float:left;
  min-height:130px;
}
.left{
  margin-left:-100%;
  left:-200px;
  width:200px;
  background:red;
}
.right{
  margin-left:-220px;
  right:-220px;
  width:220px;
  background:green;
}
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144337972-347921484.jpg)



至此，我们完成了三列中间自适应的布局，也就是传说中的圣杯布局。完整的代码如下：
```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>圣杯布局</title>
    <style type="text/css">
        *{margin: 0;padding: 0;}
        body{min-width: 700px;}
        .header,
        .footer{
            border: 1px solid #333;
            background: #aaa;
            text-align: center;
        }
        .left,
        .main,
        .right{
            position: relative;
            float: left;
            min-height: 130px;
        }
        .container{
            border: 2px solid yellow;
            padding:0 220px 0 200px;
            overflow: hidden;
        }
        .left{
            margin-left: -100%;
            left: -200px;
            width: 200px;
            background: red;
        }
        .right{
            margin-left: -220px;
            right: -220px;
            width: 220px;
            background: green;
        }
        .main{
            width: 100%;
            background: blue;
        }
        .footer{
            clear: both;
        }
    </style>
</head>
<body>
    <div class="header">header</div>
    <div class="container">
        <div class="main">main</div>
        <div class="left">left</div>
        <div class="right">right</div>
    </div>
    <div class="footer">footer</div>
</body>
</html>

```

#双飞翼布局

圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样。

1. HTML结构
```html
<div class="header">header</div>
<div class="container">
    <div class="main">
        <div class="content">main</div>
    </div>
    <div class="left">left</div>
    <div class="right">right</div>
</div>
<div class="footer">footer</div>
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144350342-1626994376.jpg)

双飞翼布局的前五步和圣杯布局完全相同，我们只需要修改第六步，前面是设置container的内边距以及相对定位来解决这个覆盖问题的，双飞翼布局中，为了main内容不被遮挡，在main里面添加一个子元素content来显示内容，然后设置content的margin-left和margin-right为左右两栏div留出位置。
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>圣杯布局</title>
    <style type="text/css">
        *{margin: 0;padding: 0;}
        body{min-width: 700px;}
        .header,
        .footer{
            border: 1px solid #333;
            background: #aaa;
            text-align: center;
        }
        .left,
        .main,
        .right{
            float: left;
            min-height: 130px;
        }
        .container{
            border: 2px solid yellow;
            overflow: hidden;
        }
        .left{
            margin-left: -100%;
            width: 200px;
            background: red;
        }
        .right{
            margin-left: -220px;
            width: 220px;
            background: green;
        }
        .main{
            width: 100%;
            background: blue;
        }
        .content{
            margin: 0 220px 0 200px;
        }
        .footer{
            clear: both;
        }
    </style>
</head>
<body>
    <div class="header">header</div>
    <div class="container">
        <div class="main">
            <div class="content">main</div>
        </div>
        <div class="left">left</div>
        <div class="right">right</div>
    </div>
    <div class="footer">footer</div>
</body>
</html>
```
双飞翼布局比圣杯布局多使用了1个div，少用大致4个css属性（圣杯布局container的 padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，；而双飞翼布局子div里用margin-left和margin-right共2个属性，比圣杯布局思路更直接和简洁一点。简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了。



##圣杯布局和双飞翼布局的作用和区别
1. 圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。

2. 圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。

3. 不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：
圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。

4. 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。
多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。

简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative"就是双飞翼布局“。
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329144411449-91607792.jpg)

#float+box-sizing+background-clip
.main元素的border区域为两侧定宽列的所在区域，实现伪等高效果；设置.main的padding和background-clip来实现元素间隔。两侧元素通过负margin调整到.main元素的border区域

　　缺点: 兼容性不好

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>三栏布局之float + box-sizing + background-clip</title>
    <style>
      body,p{
        margin: 0;
      }
      .top,.bottom{
        height: 30px;
      }
      .middle{
        overflow: hidden;
      }
      .main{
        float: left;
        width: 100%;
        border-left: 100px solid lightgrey;
        border-right: 100px solid lightgrey;
        padding: 0 20px;
        background-clip: content-box;
        box-sizing: border-box;
    }
    .left,.right{
      float: left;
      width: 100px;
    }
    .left{
      margin-left: -100%;
    }
    .right{
      margin-left: -100px;
    }

    </style>
  </head>
  <body>
    <div class="parent" id="parent" style="background-color: lightgrey;">
    <div class="top" style="background-color: lightblue;">
        <p>top</p>
    </div>
    <div class="middle" style="background-color: pink;">
        <div class="main" style="background-color: lightcoral;">
            <p>main</p>
            <p>main</p>
        </div>
        <div class="left" >
            <p>left</p>
        </div>
        <div class="right" >
               <p>right</p>
        </div>
    </div>
    <div class="bottom" style="background-color: lightgreen;">
        <p>bottom</p>
    </div>
</div>
  </body>
</html>
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329151226119-224048125.jpg)

#absolute
设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果

　　缺点: 需要为.middle元素设置高度，扩展性较差
```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>三栏布局之absolute</title>
    <style>
      body,p{margin: 0;}
      .top,.bottom{height: 30px;}
      .middle{
        position: relative;
        height: 40px;
      }
      .left,.right,.main{
        position: absolute;
        top: 0;
        bottom: 0;
      }
      .left{width: 100px;}
      .right{
        width: 100px;
        right: 0;
      }
      .main{
        left: 120px;
        right: 120px;
      }
    </style>
  </head>
  <body>
    <div class="parent" id="parent" style="background-color: lightgrey;">
    <div class="top" style="background-color: lightblue;">
        <p>top</p>
    </div>
    <div class="middle" style="background-color: pink;">
        <div class="main" style="background-color: lightcoral;">
            <p>main</p>
            <p>main</p>
        </div>
        <div class="left" style="background-color: lightseagreen;" >
            <p>left</p>
        </div>
        <div class="right" style="background-color: lightcyan;" >
               <p>right</p>
        </div>
    </div>
    <div class="bottom" style="background-color: lightgreen;">
        <p>bottom</p>
    </div>
    </div>
  </body>
</html>
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329151304860-985981928.jpg)


#flex
flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果

　　缺点: 兼容性不高
```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>三栏布局之flex</title>
    <style>
      body,p{margin: 0;}
      .top,.bottom{height: 30px;}
      .middle{display: flex;}
      .left,.right{width: 100px;}
      .right{order: 2;}
      .main{
        order: 1;
        flex: 1;
        margin: 0 20px;
      }
</style>
  </head>
  <body>
    <div class="parent" id="parent" style="background-color: lightgrey;">
    <div class="top" style="background-color: lightblue;">
        <p>top</p>
    </div>
    <div class="middle" style="background-color: pink;">
        <div class="main" style="background-color: lightcoral;">
            <p>main</p>
            <p>main</p>
        </div>
        <div class="left" style="background-color: lightseagreen;" >
            <p>left</p>
        </div>
        <div class="right" style="background-color: lightcyan;" >
               <p>right</p>
        </div>
    </div>
    <div class="bottom" style="background-color: lightgreen;">
        <p>bottom</p>
    </div>
</div>

  </body>
</html>
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329151320818-62060917.jpg)


#grid
```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>三栏布局之grid</title>
    <style>
      body,p{margin: 0;}
      .top,.bottom{height: 30px;}
      .middle{display:grid;grid-template-columns:100px 1fr 100px;grid-gap:20px;}
      .main{grid-area:1/2/2/3;}
</style>
  </head>
  <body>
    <div class="parent" id="parent" style="background-color: lightgrey;">
    <div class="top" style="background-color: lightblue;">
        <p>top</p>
    </div>
    <div class="middle" style="background-color: pink;">
        <div class="main" style="background-color: lightcoral;">
            <p>main</p>
            <p>main</p>
        </div>
        <div class="left" style="background-color: lightseagreen;" >
            <p>left</p>
        </div>
        <div class="right" style="background-color: lightcyan;" >
               <p>right</p>
        </div>
    </div>
    <div class="bottom" style="background-color: lightgreen;">
        <p>bottom</p>
    </div>
</div>

  </body>
</html>
```
![](https://img2018.cnblogs.com/blog/1502611/201903/1502611-20190329151339646-1512563042.jpg)


总结

　　由于限定了主要内容元素在html结构中位于前面，通过css样式改变将其位置调换到中间的前提，所以思路并不是很多。float浮动流的元素可以通过负margin调换位置；absolute绝对定位流的元素可以通过偏移属性调换位置；flex弹性盒模型可以通过order属性调换位置；grid通过grid-area调换位置。而处于正常流中的元素除了使用relative外，使用负margin是无法调换位置的，所以table、inline-block等布局方式在此前提下不是很实用。
