<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Web学习博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-15T08:48:06.615Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhang Quan yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS基础知识</title>
    <link href="http://yoursite.com/2019/09/15/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/09/15/JS基础知识/</id>
    <published>2019-09-15T06:11:11.000Z</published>
    <updated>2019-09-15T08:48:06.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="get-和-post的区别"><a href="#get-和-post的区别" class="headerlink" title="get 和 post的区别"></a>get 和 post的区别</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/15/ngCI6x.png" alt="ngCI6x.png" title>                </div>                <div class="image-caption">ngCI6x.png</div>            </figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgchr.com/i/ngi92R" alt="ngi92R.png](https://s2.ax1x.com/2019/09/15/ngi92R.png)" title>                </div>                <div class="image-caption">ngi92R.png](https://s2.ax1x.com/2019/09/15/ngi92R.png)</div>            </figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建方式即在一个函数内部创建另一个函数。</p><pre><code>function outer(){        var i=0;        return function(){            console.log(i++);        }    }    var getNum = outer();    getNum();    i=1;    getNum();</code></pre><p>图解：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nYpOqe.png" alt="nYpOqe.png" title>                </div>                <div class="image-caption">nYpOqe.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9FsS.png" alt="nY9FsS.png" title>                </div>                <div class="image-caption">nY9FsS.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9nGq.png" alt="nY9nGq.png" title>                </div>                <div class="image-caption">nY9nGq.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9cFA.png" alt="nY9cFA.png" title>                </div>                <div class="image-caption">nY9cFA.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9WSP.png" alt="nY9WSP.png" title>                </div>                <div class="image-caption">nY9WSP.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9fQf.png" alt="nY9fQf.png" title>                </div>                <div class="image-caption">nY9fQf.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9Ieg.png" alt="nY9Ieg.png" title>                </div>                <div class="image-caption">nY9Ieg.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nY9vOU.png" alt="nY9vOU.png" title>                </div>                <div class="image-caption">nY9vOU.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nYCSw4.png" alt="nYCSw4.png" title>                </div>                <div class="image-caption">nYCSw4.png</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/09/nYCpTJ.png" alt="nYCpTJ.png" title>                </div>                <div class="image-caption">nYCpTJ.png</div>            </figure></p><h2 id="使用闭包-封装私有变量"><a href="#使用闭包-封装私有变量" class="headerlink" title="使用闭包-封装私有变量"></a>使用闭包-封装私有变量</h2><pre><code>function Ninja(){    var feints = 0;    this.getFeints = function(){        return feints;    };    this.feint = function(){        feints++;    };}var ninja1 = new Ninja();ninja1.feint();console.log(ninja1.feints === undefined,&quot;无法直接获取该变量&quot;);console.log(ninja1.getFeints() === 1,&quot;可以通过getFeints反复操作变量feints&quot;);var ninja2 = new Ninja();console.log(ninja2.getFeints() === 0,&quot;ninja2具有自己的私有feints变量&quot;);</code></pre><h2 id="使用闭包-回调函数"><a href="#使用闭包-回调函数" class="headerlink" title="使用闭包-回调函数"></a>使用闭包-回调函数</h2><p>回调函数指的是需要在将来不确定的某一时刻异步调用的函数。</p><pre><code>&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;script&gt;  function animateIt(elementId){      var elem = document.getElementById(elementId);      var tick = 0;      var timer = setInterval(function(){          if(tick &lt;100){              elem.style.left = elem.style.top = tick + &quot;px&quot;;              tick++;          }else{              clearInterval(timer);              console.log(tick === 100);              console.log(elem);              console.log(timer);          }      },10);  }  animateIt(&quot;box1&quot;);&lt;/script&gt;</code></pre><h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><h1 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><h2 id="Object构造函数"><a href="#Object构造函数" class="headerlink" title="Object构造函数"></a>Object构造函数</h2><p>缺点：虽然构造函数或字面量都可以用来创建单个对象，明显的缺点是使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，使用工厂模式。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>function createPerson(name,age,job){    var o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function(){        console.log(this.name);    };    return o;}var person1 = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = createPerson(&quot;Greg&quot;,27,&quot;Docror&quot;); </code></pre><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><pre><code>function Person(name,age,job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = function(){        console.log(this.name);    }}var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</code></pre><p>new一个对象会有哪几步：<br>（1）创建一个新对象<br>（2）将构造函数的作用域赋给新对象<br>（3）执行构造函数中的代码（为这个新对象添加属性）<br>（4）返回新对象</p><p>构造函数的问题：每个方法都要在每个实例上重新创建一遍。<br>解决：原型模式</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>prototype通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象shilling共享它所包含的属性和方法。</p><p>构造函数与原型对象：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</p><p>实例与原型对象：当调用构造函数创建一个实例后，该实例的内部指针<strong>proto</strong>指向构造函数的原型对象，这个属性对脚本是完全不可见的。</p><h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><h1 id="如何解决异步回调地狱"><a href="#如何解决异步回调地狱" class="headerlink" title="如何解决异步回调地狱"></a>如何解决异步回调地狱</h1><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h1 id="前端事件流"><a href="#前端事件流" class="headerlink" title="前端事件流"></a>前端事件流</h1><p>事件流是指从页面中接收事件的顺序。<br>IE的事件流是事件冒泡流。<br>Netscape的事件流是指事件捕获流。</p><h2 id="IE事件流"><a href="#IE事件流" class="headerlink" title="IE事件流"></a>IE事件流</h2><p>IE事件流叫事件冒泡。即事件开始由最具体的元素接收，然后逐级向上传播到较为不具体的节点。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/15/ngG1OK.png" alt="ngG1OK.png" title>                </div>                <div class="image-caption">ngG1OK.png</div>            </figure></p><p>所有现代浏览器都支持事件冒泡，但是具体实现上还有一些差别。</p><h2 id="Netscape事件捕获"><a href="#Netscape事件捕获" class="headerlink" title="Netscape事件捕获"></a>Netscape事件捕获</h2><p>Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击 <div>元素就会以下列顺序触发 click 事件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/15/ngGX11.png" alt="ngGX11.png" title>                </div>                <div class="image-caption">ngGX11.png</div>            </figure></div></p><p>由于老版本的浏览器不支持，因此很少人使用时间捕获。</p><h2 id="DOM级事件"><a href="#DOM级事件" class="headerlink" title="DOM级事件"></a>DOM级事件</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/09/15/ngJ7KP.png" alt="ngJ7KP.png" title>                </div>                <div class="image-caption">ngJ7KP.png</div>            </figure></p><p>多数支持DOM事件流的浏览器都实现了一种特定的行为：即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9,Safari,Chrome,Firefox和Opera 9.5及更高版本都会在捕获阶段触发事件对象上的事件。</p><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p>事件是用户或浏览器自身执行的某种动作，而响应某个事件的函数叫做事件处理程序。（事件侦听器）</p><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><h2 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h2><h2 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h2><h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><h2 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h2><h1 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h1><p>在DOM0标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托是指不在事件的发生地上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><p>对“事件处理程序过多”问题的解决方案就是事件委托。<br>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><p>优点：<br>（1）document对象很快可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序。即只要可单击的元素呈现在页面上，就可以立即具备适当的功能。<br>（2）在页面中设置事件处理程序所需要的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。<br>（3）整个页面占用的内存空间更少，能够提升整体性能。</p><h1 id="图片懒加载和预加载"><a href="#图片懒加载和预加载" class="headerlink" title="图片懒加载和预加载"></a>图片懒加载和预加载</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;get-和-post的区别&quot;&gt;&lt;a href=&quot;#get-和-post的区别&quot; class=&quot;headerlink&quot; title=&quot;get 和 post的区别&quot;&gt;&lt;/a&gt;get 和 post的区别&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
</feed>
