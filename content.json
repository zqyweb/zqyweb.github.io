{"meta":{"title":"Web学习博客","subtitle":null,"description":null,"author":"Zhang Quan yu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"My Blog Name | 404","date":"2019-09-15T02:48:46.672Z","updated":"2019-09-15T02:48:46.672Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-06T13:34:07.000Z","updated":"2019-09-06T13:35:22.868Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categories comments: false"},{"title":"","date":"2019-09-06T13:33:18.969Z","updated":"2019-09-06T13:33:18.969Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tags comments: false"}],"posts":[{"title":"JS基础知识","slug":"JS基础知识","date":"2019-09-15T06:11:11.000Z","updated":"2019-09-15T08:48:06.615Z","comments":true,"path":"2019/09/15/JS基础知识/","link":"","permalink":"http://yoursite.com/2019/09/15/JS基础知识/","excerpt":"","text":"get 和 post的区别 ngCI6x.png [ ngi92R.png](https://s2.ax1x.com/2019/09/15/ngi92R.png) 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建方式即在一个函数内部创建另一个函数。 function outer(){ var i=0; return function(){ console.log(i++); } } var getNum = outer(); getNum(); i=1; getNum(); 图解： nYpOqe.png nY9FsS.png nY9nGq.png nY9cFA.png nY9WSP.png nY9fQf.png nY9Ieg.png nY9vOU.png nYCSw4.png nYCpTJ.png 使用闭包-封装私有变量function Ninja(){ var feints = 0; this.getFeints = function(){ return feints; }; this.feint = function(){ feints++; }; } var ninja1 = new Ninja(); ninja1.feint(); console.log(ninja1.feints === undefined,&quot;无法直接获取该变量&quot;); console.log(ninja1.getFeints() === 1,&quot;可以通过getFeints反复操作变量feints&quot;); var ninja2 = new Ninja(); console.log(ninja2.getFeints() === 0,&quot;ninja2具有自己的私有feints变量&quot;); 使用闭包-回调函数回调函数指的是需要在将来不确定的某一时刻异步调用的函数。 &lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt; &lt;script&gt; function animateIt(elementId){ var elem = document.getElementById(elementId); var tick = 0; var timer = setInterval(function(){ if(tick &lt;100){ elem.style.left = elem.style.top = tick + &quot;px&quot;; tick++; }else{ clearInterval(timer); console.log(tick === 100); console.log(elem); console.log(timer); } },10); } animateIt(&quot;box1&quot;); &lt;/script&gt; 闭包的缺点对象的创建方式字面量Object构造函数缺点：虽然构造函数或字面量都可以用来创建单个对象，明显的缺点是使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，使用工厂模式。 工厂模式function createPerson(name,age,job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name); }; return o; } var person1 = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;); var person2 = createPerson(&quot;Greg&quot;,27,&quot;Docror&quot;); 构造函数模式function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); } } var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;); new一个对象会有哪几步：（1）创建一个新对象（2）将构造函数的作用域赋给新对象（3）执行构造函数中的代码（为这个新对象添加属性）（4）返回新对象 构造函数的问题：每个方法都要在每个实例上重新创建一遍。解决：原型模式 原型模式prototype通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象shilling共享它所包含的属性和方法。 构造函数与原型对象：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。 实例与原型对象：当调用构造函数创建一个实例后，该实例的内部指针proto指向构造函数的原型对象，这个属性对脚本是完全不可见的。 组合使用构造函数模式和原型模式动态原型模式寄生构造函数模式稳妥构造函数模式继承原型链借用构造函数组合继承原型式继承寄生式继承寄生组合式继承如何解决异步回调地狱PromiseGeneratorasync/await前端事件流事件流是指从页面中接收事件的顺序。IE的事件流是事件冒泡流。Netscape的事件流是指事件捕获流。 IE事件流IE事件流叫事件冒泡。即事件开始由最具体的元素接收，然后逐级向上传播到较为不具体的节点。 ngG1OK.png 所有现代浏览器都支持事件冒泡，但是具体实现上还有一些差别。 Netscape事件捕获Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击 元素就会以下列顺序触发 click 事件。 ngGX11.png 由于老版本的浏览器不支持，因此很少人使用时间捕获。 DOM级事件“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。 ngJ7KP.png 多数支持DOM事件流的浏览器都实现了一种特定的行为：即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9,Safari,Chrome,Firefox和Opera 9.5及更高版本都会在捕获阶段触发事件对象上的事件。 事件处理程序事件是用户或浏览器自身执行的某种动作，而响应某个事件的函数叫做事件处理程序。（事件侦听器） HTML事件处理程序DOM0级事件处理程序DOM2级事件处理程序IE事件处理程序跨浏览器的事件处理程序如何让事件先冒泡后捕获在DOM0标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 事件委托事件委托是指不在事件的发生地上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 优点：（1）document对象很快可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序。即只要可单击的元素呈现在页面上，就可以立即具备适当的功能。（2）在页面中设置事件处理程序所需要的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。（3）整个页面占用的内存空间更少，能够提升整体性能。 图片懒加载和预加载","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]}]}