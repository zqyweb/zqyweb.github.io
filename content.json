{"meta":{"title":"Web学习博客","subtitle":null,"description":null,"author":"Zhang Quan yu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-06T13:34:07.000Z","updated":"2019-09-06T13:35:22.868Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categories comments: false"},{"title":"","date":"2019-09-06T13:33:18.969Z","updated":"2019-09-06T13:33:18.969Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tags comments: false"}],"posts":[{"title":"多方式实现三栏布局","slug":"多方式实现三栏布局","date":"2019-09-08T13:02:56.000Z","updated":"2019-09-08T13:38:09.611Z","comments":true,"path":"2019/09/08/多方式实现三栏布局/","link":"","permalink":"http://yoursite.com/2019/09/08/多方式实现三栏布局/","excerpt":"","text":"前端知识1.用最多的方式实现三栏布局？&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; 1. 圣杯布局 .container { overflow: hidden; padding: 0 200px; } .container&gt;div { position: relative; float: left; height: 100px; } .center { width: 100%; background-color: red; } .left { width: 200px; background-color: green; margin-left: -100%; left: -200px; } .right { width: 200px; background-color: blue; margin-left: -200px; right: -200px; } 2. flex布局.container { display: flex; } .center { background-color: red; width: 100%; order: 2; } .left { background-color: green; width: 200px; flex-shrink: 0; order: 1; } .right { background-color: blue; width: 200px; flex-shrink: 0; order: 3; } 3. 绝对定位布局.center { position: absolute; left: 200px; right: 200px; height: 300px; background-color: yellow; } .left { position: absolute; left: 0px; width: 200px; height: 300px; background-color: red; } .right { position: absolute; right: 0px; width: 200px; background-color: green; height: 300px; } 4. 双飞翼布局.container { overflow: hidden; } .container&gt;div { position: relative; float: left; height: 100px; } .center { width: 100%; background-color: red; } .left { width: 200px; background-color: green; margin-left: -100%; } .right { width: 200px; background-color: blue; margin-left: -200px; } .main { height: 100%; margin: 0 200px; background-color: rosybrown; overflow: hidden; } 2.float布局对后续元素的影响？","categories":[],"tags":[{"name":"HTML CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/tags/HTML-CSS/"}]},{"title":"JS基础","slug":"JS基础","date":"2019-09-08T13:02:56.000Z","updated":"2019-09-09T14:22:25.129Z","comments":true,"path":"2019/09/08/JS基础/","link":"","permalink":"http://yoursite.com/2019/09/08/JS基础/","excerpt":"","text":"前端知识1.闭包1.1闭包是什么闭包是指有权访问另一个函数作用域的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 function outer(){ var i=0; return function(){ console.log(i++); } } var getNum = outer(); getNum(); i=1; getNum(); 图解： nYpOqe.png nY9FsS.png nY9nGq.png nY9cFA.png nY9WSP.png nY9fQf.png nY9Ieg.png nY9vOU.png nYCSw4.png nYCpTJ.png 1.2闭包与变量闭包只能取得包含函数中年任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量。举个例子 function createFunctions(){ var result = new Array(); for (var i=0; i &lt; 10; i++){ result[i] = function(){ return i; }; } return result; } 每个函数都返回10.因为每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以它们引用的都是同一个变量 i 。当createFunctions() 函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i的同一个变量对象，所以在每个函数内部 i 的值都是 10。 可以通过创建另一个匿名函数强制让闭包的行为符合预期 function createFunctions(){ var result = new Array(); for(var i=0;i&lt;10;i++){ result[i] = function(num){ return function(){ return num; }; }(i); } return result; } 每个函数就会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问 num的闭包。这样一来， result 数组中的每个函数都有自己num 变量的一个副本，因此就可以返回各自不同的数值了。 1.3关于this对象this对象是在运行是基于函数的执行环境绑定的：在全局函数中，this等于window；而当函数作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，所以其this指向window。 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); //&quot;The Window&quot;（在非严格模式下） 原因：每个函数在被调用时都会自动取得两个特殊变量： this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ var that = this;// return function(){ return that.name; }; } }; alert(object.getNameFunc()()); //&quot;My Object&quot; 1.4内存泄漏如果闭包的作用域链中保存着一个HTML元素，那么就以为着该元素将无法被销毁。有必要将使用完的变量设置为null. 1.5模仿块级作用域JS不会告诉你是否多次声明了同一个变量；会执行后续声明中的变量初始化。匿名函数可以模仿块级作用域(私有作用域)避免这个问题。 (function(){ //块级作用域 })(); var someFunction = function(){ //这里是块级作用域 }； someFunction(); 私有变量小结当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 使用闭包可以在 JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下。 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。 2.作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 JavaScript原型，原型链 ? 有什么特点？1.概念 原型对象：每个函数都会有一个prototype(原型)属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思解释，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 __proto__ :创建自定义的构造函数之后，其原型对象默认之后取得constructor属性；其他方法都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 __proto__,指向构造函数的原型对象。 nY3336.png 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 function Person(){} Person.prototype.name = &quot;Ni&quot;; Person.prototype.age = 29; Person.prototype.job=&quot;Software Engineer&quot;; Person.prototype.sayName = function(){ console.log(); }this.name); } var person1 = new Person(); person1.sayName(); var person2 = new Person(); person2.sayName(); console.log(person1.sayName == person2.sayName2); 2.关系 Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person. new的实例person1内部属性__proto__指向Person的原型对象（Person.prototype）。3.判断关系 判断原型对象与实例对象之间是否存在关系isPrototype（），如果实例对象内部__proto__指向原型对象，结果返回true. console.log(Person.prototype.isPrototypeOf(person1));//true console.log(Person.prototype.isPrototypeOf(person2));//true Object.getPrototypeOf()，返回对象的原型（[[Prototype]]）的值。 console.log(Object.getPrototypeOf(person1) == Person.prototype);//true console.log(Object.getPrototypeOf(person1).name);//Ni hasOwnPrototype可以检测一个属性是否存在于实例中，还是存在于原型中。存在于实例对象中才会返回true. 4.原型与inin操作符会在通过对象能够访问给定属性时返回true,不论该属性存在于实例中还是原型中。同时使用hasOwnProperty()和in操作符，可以确定该属性到底是存在于对象中，还是原型中。 function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name) &amp;&amp; (name in object); } 果然该属性存在于返回y原型中，就返回true;存在于实例中就返回false.5.原型的动态性（P175 ） 4 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒可以实现当新增子对象时无需再次对其绑定 5 Javascript如何实现继承？6.this对象1、说明：this对象在运行时基于函数的执行环境绑定的：在全局函数中，this等于window,当函数被作为某个对象的方法调用时，this等于那个对象，不过匿名函数的执行环境具有全局性，因此this通常指向window2、下面是几种常见的情况 （1）this指向window var a = 123 function test(){ console.log(this) } test()//winndow （2）在构造函数中this指向实例化对象 function test(){ alert(this.a); } test();//window---------这里调用全局中的函数，自然是指向window var t = new test(); //---------这里是将test（）作为一个构造函数， alert(t.a);// undefined undefined (3)对象中的this就是指向当前对象，节点也是对象， var obj = { name:&#39;xxm&#39;, age:18, sayHi:function(){ alert(this.name) } } obj.sayHi()//xxm --------this指向当前对象 （4）注意匿名函数的this对象指向window var name = &quot;This window&quot; var obj = { name:&quot;my obj&quot;, getNameFun:function(){ return function(){//这是匿名函数 return this.name } } } alert(obj.getNameFun()())//调用匿名函数---window 解决： var name = &quot;This window&quot; var obj = { name:&quot;my obj&quot;, getNameFun:function(){ var that = this return function(){//这是匿名函数 return that.name } } } alert(obj.getNameFun()())//调用匿名函数---window 3、总结 调用形式 this指向普通函数 window构造函数 实例化后的对象对象的方法 该对象DOM节点 该节点对象call或者apply，bind 第一个参数 call，apply，bind的区别？call只能一个参数一个参数的传入。apply则只支持传入一个数组，最终调用函数时候这个数组会拆成一个个参数分别传入。bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。bind传参方式跟call方法一致。 7.事件模型JavaScript事件模型主要分为3种：原始事件模型、DOM2事件模型、IE事件模型。 1.原始事件模型（DOM0级）这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件：（1）在html代码中直接指定属性值：&lt;button id=&quot;demo&quot; type=&quot;button&quot; onclick=&quot;doSomeTing()&quot; /&gt; （2）在js代码中为 document.getElementsById(&quot;demo&quot;).onclick = doSomeTing() 优点：所有浏览器都兼容 缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。 因为这些缺点，虽然原始事件类型兼容所有浏览器，但仍不推荐使用。 2.DOM2事件模型此模型是W3C制定的标准模型，现代浏览器（IE6~8除外）都已经遵循这个规范。W3C制定的事件模型中，一次事件的发生包含三个过程： (1).事件捕获阶段，(2).事件目标阶段，(3).事件冒泡阶段。如下图所示 事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。 所有的事件类型都会经历事件捕获但是只有部分事件会经历事件冒泡阶段,例如submit事件就不会被冒泡。 事件的传播是可以阻止的： • 在W3c中，使用stopPropagation（）方法 • 在IE下设置cancelBubble = true； • 在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。 标准的事件监听器该如何绑定： addEventListener(&quot;eventType&quot;,&quot;handler&quot;,&quot;true|false&quot;);其中eventType指事件类型，注意不要加‘on’前缀，与IE下不同。第二个参数是处理函数，第三个即用来指定是否在捕获阶段进行处理，一般设为false来与IE保持一致(默认设置)，除非你有特殊的逻辑需求。监听器的解除也类似：removeEventListner(&quot;eventType&quot;,&quot;handler&quot;,&quot;true!false&quot;); 3.IE事件模型 IE不把该对象传入事件处理函数,由于在任意时刻只会存在一个事件,所以IE把它作为全局对象window的一个属性，为求证其真伪，使用IE8执行代码alert(window.event)，结果弹出是null，说明该属性已经定义，只是值为null（与undefined不同）。难道这个全局对象的属性是在监听函数里才加的？于是执行下面代码： window.onload = function (){alert(window.event);} setTimeout(function(){alert(window.event);},2000); 结果第一次弹出【object event】，两秒后弹出依然是null。由此可见IE是将event对象在处理函数中设为window的属性，一旦函数执行结束，便被置为null了。IE的事件模型只有两步，先执行元素的监听函数，然后事件沿着父节点一直冒泡到document。冒泡已经讲解过了，这里不重复。IE模型下的事件监听方式也挺独特，绑定监听函数的方法是：attachEvent( &quot;eventType&quot;,&quot;handler&quot;)，其中evetType为事件的类型，如onclick，注意要加’on’。解除事件监听器的方法是 detachEvent(&quot;eventType&quot;,&quot;handler&quot; ) IE的事件模型已经可以解决原始模型的三个缺点，但其自己的缺点就是兼容性，只有IE系列浏览器才可以这样写。 以上就是3种事件模型，在我们写代码的时候，为了兼容ie，通常使用以下写法： var demo = document.getElementById(&#39;demo&#39;); if(demo.attachEvent){ demo.attachEvent(&#39;onclick&#39;,func); }else{ demo.addEventListener(&#39;click&#39;,func,false); } 8.new操作符具体干了什么？ 1. 创建新的空对象: 2. 然后让这个空对象的__proto__指向函数的原型prototype。只要使用构造函数创建一个子对象时，都会让子对象自动继承构造函数的原型对象 3. 调用构造函数，向对象中添加新属性 new自动修改this为正在创建的新对象 4. 返回新对象地址，保存到变量中 nthNB8.png 9 Ajax原理","categories":[],"tags":[{"name":"HTML CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/tags/HTML-CSS/"}]},{"title":"","slug":"页面布局/三栏布局/三栏布局之grid","date":"2019-03-29T07:07:11.576Z","updated":"2019-03-29T07:09:06.056Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/三栏布局之grid/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/三栏布局之grid/","excerpt":"","text":"三栏布局之grid body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{display:grid;grid-template-columns:100px 1fr 100px;grid-gap:20px;} .main{grid-area:1/2/2/3;} top main main left right bottom","categories":[],"tags":[]},{"title":"","slug":"页面布局/三栏布局/三栏布局之flex","date":"2019-03-29T07:04:31.328Z","updated":"2019-03-29T07:05:44.418Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/三栏布局之flex/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/三栏布局之flex/","excerpt":"","text":"三栏布局之flex body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{display: flex;} .left,.right{width: 100px;} .right{order: 2;} .main{ order: 1; flex: 1; margin: 0 20px; } top main main left right bottom","categories":[],"tags":[]},{"title":"","slug":"页面布局/三栏布局/三栏布局之absolute","date":"2019-03-29T07:01:12.233Z","updated":"2019-03-29T07:05:08.149Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/三栏布局之absolute/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/三栏布局之absolute/","excerpt":"","text":"三栏布局之absolute body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{ position: relative; height: 40px; } .left,.right,.main{ position: absolute; top: 0; bottom: 0; } .left{width: 100px;} .right{ width: 100px; right: 0; } .main{ left: 120px; right: 120px; } top main main left right bottom #flex flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果 缺点: 兼容性不高","categories":[],"tags":[]},{"title":"","slug":"页面布局/三栏布局/三栏布局之float+box sizong+background-clip","date":"2019-03-29T06:54:31.748Z","updated":"2019-03-29T06:58:39.630Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/三栏布局之float+box sizong+background-clip/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/三栏布局之float+box sizong+background-clip/","excerpt":"","text":"三栏布局之float + box-sizing + background-clip body,p{ margin: 0; } .top,.bottom{ height: 30px; } .middle{ overflow: hidden; } .main{ float: left; width: 100%; border-left: 100px solid lightgrey; border-right: 100px solid lightgrey; padding: 0 20px; background-clip: content-box; box-sizing: border-box; } .left,.right{ float: left; width: 100px; } .left{ margin-left: -100%; } .right{ margin-left: -100px; } top main main left right bottom","categories":[],"tags":[]},{"title":"","slug":"页面布局/三栏布局","date":"2019-03-29T05:51:11.707Z","updated":"2019-03-29T07:14:17.505Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/","excerpt":"","text":"#圣杯布局布局要求： 三列布局，中间宽度自适应，两边定宽 中间栏要在浏览器中优先展示渲染 允许任意列的高度最高 &lt;div class=\"header\">header&lt;/div> &lt;div class=\"container\"> &lt;div class=\"main\">main&lt;/div> &lt;div class=\"left\">left&lt;/div> &lt;div class=\"right\">right&lt;/div> &lt;/div> &lt;div class=\"footer\">footer&lt;/div> 因为需要中间栏优先展示渲染，所以中间的main在HTML的结构中却是最靠前的。在实际的网站中这样做的好处就是用户能够先看到网页正文信息，一般网页两边的导航信息和说明信息我们认为优先级没有正文重要。 设置基本样式*{margin:0;padding:0;} body{ min-width:700px; } .header,.footer{ border:1px solid #333; background:#aaa; text-align:center; } .left,.main,.right{ min-height:130px; float:left; } .container{ border:2px solid yellow; } .left{ width:200px; background:red; } .right{ width:220px; background:green; } .main{ background:blue; } 为了高度保持一致给left middle right都加上min-height:130px 将主体部分的三个子元素都设置左浮动.left,.main,.right{ float:left; } 我们看一下上面的效果比较明显的两个问题，一是footer跑到上面去了，二是container容器高度塌陷了，这是典型的“清除浮动和闭合浮动”问题。 解决浮动问题.container{ border:2px solid yellow; overflow:hidden; } .footer{ clear:both; } 给container加上overflow:hidden触发BFC闭合浮动，给footer加上clear属性清除浮动。 我们发现footer移到了下面，并且container的高度塌陷也修复了。 设置main宽度为width:100%,让其独占满一行.main{width:100%;background:blue;} 设置left和right负的外边距我们的目标是让left、main、right依次并排，但是上图中left和right都是位于下一行，这里的技巧就是使用负的margin-left:.left{ margin-left:-100%; width:200px; background:red; } .right{ margin-left:-220px; width:220px; background:green; } 负的margin-left会让元素沿文档流向左移动，如果负的数值比较大就会一直移动到上一行。关于负的margin的应用也是博大精深，这里肯定是不能详细介绍了。设置left部分的margin-left为-100%,就会使left向左移动一整个行的宽度，由于left左边是父元素的边框，所以left继续跳到上一行左移，一直移动到上一行的开头，并覆盖了main部分（仔细观察下图，你会发现main里面的字“main”不见了，因为被left遮住了），left上移过后，right就会处于上一行的开头位置，这是再设置right部分margin-left为负的宽度，right就会左移到上一行的末尾。 修复覆盖问题第五步我们说过设置left和right负的外边距覆盖了main部分的内容，现在想办法修复这个问题，首先给container的左右加上一个内边距，分别为left和right的宽度。.container{ border:2px solid yellow; padding:0 220px 0 200px; overflow:hidden; } 由于left、main、right三个部分都被container包裹着，所以给其添加内边距，三个子元素会往中间挤。貌似还是没有修复问题，别着急，我们已经在container的左右两边留下了相应宽度的留白，只要把left和right分别移动到这两个留白就可以了。可以使用相对定位移动left和right部分， .left,.main,.right{ position:relative; float:left; min-height:130px; } .left{ margin-left:-100%; left:-200px; width:200px; background:red; } .right{ margin-left:-220px; right:-220px; width:220px; background:green; } 至此，我们完成了三列中间自适应的布局，也就是传说中的圣杯布局。完整的代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{margin: 0;padding: 0;} body{min-width: 700px;} .header, .footer{ border: 1px solid #333; background: #aaa; text-align: center; } .left, .main, .right{ position: relative; float: left; min-height: 130px; } .container{ border: 2px solid yellow; padding:0 220px 0 200px; overflow: hidden; } .left{ margin-left: -100%; left: -200px; width: 200px; background: red; } .right{ margin-left: -220px; right: -220px; width: 220px; background: green; } .main{ width: 100%; background: blue; } .footer{ clear: both; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; #双飞翼布局 圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样。 HTML结构&lt;div class=\"header\">header&lt;/div> &lt;div class=\"container\"> &lt;div class=\"main\"> &lt;div class=\"content\">main&lt;/div> &lt;/div> &lt;div class=\"left\">left&lt;/div> &lt;div class=\"right\">right&lt;/div> &lt;/div> &lt;div class=\"footer\">footer&lt;/div> 双飞翼布局的前五步和圣杯布局完全相同，我们只需要修改第六步，前面是设置container的内边距以及相对定位来解决这个覆盖问题的，双飞翼布局中，为了main内容不被遮挡，在main里面添加一个子元素content来显示内容，然后设置content的margin-left和margin-right为左右两栏div留出位置。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>圣杯布局&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} body{min-width: 700px;} .header, .footer{ border: 1px solid #333; background: #aaa; text-align: center; } .left, .main, .right{ float: left; min-height: 130px; } .container{ border: 2px solid yellow; overflow: hidden; } .left{ margin-left: -100%; width: 200px; background: red; } .right{ margin-left: -220px; width: 220px; background: green; } .main{ width: 100%; background: blue; } .content{ margin: 0 220px 0 200px; } .footer{ clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"header\">header&lt;/div> &lt;div class=\"container\"> &lt;div class=\"main\"> &lt;div class=\"content\">main&lt;/div> &lt;/div> &lt;div class=\"left\">left&lt;/div> &lt;div class=\"right\">right&lt;/div> &lt;/div> &lt;div class=\"footer\">footer&lt;/div> &lt;/body> &lt;/html> 双飞翼布局比圣杯布局多使用了1个div，少用大致4个css属性（圣杯布局container的 padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，；而双飞翼布局子div里用margin-left和margin-right共2个属性，比圣杯布局思路更直接和简洁一点。简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了。 ##圣杯布局和双飞翼布局的作用和区别 圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。 不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。 简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative”就是双飞翼布局“。 #float+box-sizing+background-clip.main元素的border区域为两侧定宽列的所在区域，实现伪等高效果；设置.main的padding和background-clip来实现元素间隔。两侧元素通过负margin调整到.main元素的border区域 缺点: 兼容性不好 &lt;!DOCTYPE html> &lt;html lang=\"en\" dir=\"ltr\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>三栏布局之float + box-sizing + background-clip&lt;/title> &lt;style> body,p{ margin: 0; } .top,.bottom{ height: 30px; } .middle{ overflow: hidden; } .main{ float: left; width: 100%; border-left: 100px solid lightgrey; border-right: 100px solid lightgrey; padding: 0 20px; background-clip: content-box; box-sizing: border-box; } .left,.right{ float: left; width: 100px; } .left{ margin-left: -100%; } .right{ margin-left: -100px; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"parent\" id=\"parent\" style=\"background-color: lightgrey;\"> &lt;div class=\"top\" style=\"background-color: lightblue;\"> &lt;p>top&lt;/p> &lt;/div> &lt;div class=\"middle\" style=\"background-color: pink;\"> &lt;div class=\"main\" style=\"background-color: lightcoral;\"> &lt;p>main&lt;/p> &lt;p>main&lt;/p> &lt;/div> &lt;div class=\"left\" > &lt;p>left&lt;/p> &lt;/div> &lt;div class=\"right\" > &lt;p>right&lt;/p> &lt;/div> &lt;/div> &lt;div class=\"bottom\" style=\"background-color: lightgreen;\"> &lt;p>bottom&lt;/p> &lt;/div> &lt;/div> &lt;/body> &lt;/html> #absolute设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果 缺点: 需要为.middle元素设置高度，扩展性较差 &lt;!DOCTYPE html> &lt;html lang=\"en\" dir=\"ltr\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>三栏布局之absolute&lt;/title> &lt;style> body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{ position: relative; height: 40px; } .left,.right,.main{ position: absolute; top: 0; bottom: 0; } .left{width: 100px;} .right{ width: 100px; right: 0; } .main{ left: 120px; right: 120px; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"parent\" id=\"parent\" style=\"background-color: lightgrey;\"> &lt;div class=\"top\" style=\"background-color: lightblue;\"> &lt;p>top&lt;/p> &lt;/div> &lt;div class=\"middle\" style=\"background-color: pink;\"> &lt;div class=\"main\" style=\"background-color: lightcoral;\"> &lt;p>main&lt;/p> &lt;p>main&lt;/p> &lt;/div> &lt;div class=\"left\" style=\"background-color: lightseagreen;\" > &lt;p>left&lt;/p> &lt;/div> &lt;div class=\"right\" style=\"background-color: lightcyan;\" > &lt;p>right&lt;/p> &lt;/div> &lt;/div> &lt;div class=\"bottom\" style=\"background-color: lightgreen;\"> &lt;p>bottom&lt;/p> &lt;/div> &lt;/div> &lt;/body> &lt;/html> #flexflex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果 缺点: 兼容性不高 &lt;!DOCTYPE html> &lt;html lang=\"en\" dir=\"ltr\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>三栏布局之flex&lt;/title> &lt;style> body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{display: flex;} .left,.right{width: 100px;} .right{order: 2;} .main{ order: 1; flex: 1; margin: 0 20px; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"parent\" id=\"parent\" style=\"background-color: lightgrey;\"> &lt;div class=\"top\" style=\"background-color: lightblue;\"> &lt;p>top&lt;/p> &lt;/div> &lt;div class=\"middle\" style=\"background-color: pink;\"> &lt;div class=\"main\" style=\"background-color: lightcoral;\"> &lt;p>main&lt;/p> &lt;p>main&lt;/p> &lt;/div> &lt;div class=\"left\" style=\"background-color: lightseagreen;\" > &lt;p>left&lt;/p> &lt;/div> &lt;div class=\"right\" style=\"background-color: lightcyan;\" > &lt;p>right&lt;/p> &lt;/div> &lt;/div> &lt;div class=\"bottom\" style=\"background-color: lightgreen;\"> &lt;p>bottom&lt;/p> &lt;/div> &lt;/div> &lt;/body> &lt;/html> #grid &lt;!DOCTYPE html> &lt;html lang=\"en\" dir=\"ltr\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>三栏布局之grid&lt;/title> &lt;style> body,p{margin: 0;} .top,.bottom{height: 30px;} .middle{display:grid;grid-template-columns:100px 1fr 100px;grid-gap:20px;} .main{grid-area:1/2/2/3;} &lt;/style> &lt;/head> &lt;body> &lt;div class=\"parent\" id=\"parent\" style=\"background-color: lightgrey;\"> &lt;div class=\"top\" style=\"background-color: lightblue;\"> &lt;p>top&lt;/p> &lt;/div> &lt;div class=\"middle\" style=\"background-color: pink;\"> &lt;div class=\"main\" style=\"background-color: lightcoral;\"> &lt;p>main&lt;/p> &lt;p>main&lt;/p> &lt;/div> &lt;div class=\"left\" style=\"background-color: lightseagreen;\" > &lt;p>left&lt;/p> &lt;/div> &lt;div class=\"right\" style=\"background-color: lightcyan;\" > &lt;p>right&lt;/p> &lt;/div> &lt;/div> &lt;div class=\"bottom\" style=\"background-color: lightgreen;\"> &lt;p>bottom&lt;/p> &lt;/div> &lt;/div> &lt;/body> &lt;/html> 总结 由于限定了主要内容元素在html结构中位于前面，通过css样式改变将其位置调换到中间的前提，所以思路并不是很多。float浮动流的元素可以通过负margin调换位置；absolute绝对定位流的元素可以通过偏移属性调换位置；flex弹性盒模型可以通过order属性调换位置；grid通过grid-area调换位置。而处于正常流中的元素除了使用relative外，使用负margin是无法调换位置的，所以table、inline-block等布局方式在此前提下不是很实用。","categories":[],"tags":[]},{"title":"","slug":"页面布局/三栏布局/2.1圣杯布局","date":"2019-03-29T03:04:34.300Z","updated":"2019-03-29T05:50:49.766Z","comments":true,"path":"2019/03/29/页面布局/三栏布局/2.1圣杯布局/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/三栏布局/2.1圣杯布局/","excerpt":"","text":"圣杯布局 *{margin: 0;padding: 0;} body{min-width: 700px;} .header, .footer{ border: 1px solid #333; background: #aaa; text-align: center; } .left, .main, .right{ position: relative; float: left; min-height: 130px; } .container{ border: 2px solid yellow; padding:0 220px 0 200px; overflow: hidden; } .left{ margin-left: -100%; left: -200px; width: 200px; background: red; } .right{ margin-left: -220px; right: -220px; width: 220px; background: green; } .main{ width: 100%; background: blue; } .footer{ clear: both; } header main left right footer","categories":[],"tags":[]},{"title":"","slug":"页面布局/页面布局demo/1.4去除列表最后一个li元素的border-bottom","date":"2019-03-29T02:49:28.360Z","updated":"2019-03-29T02:59:48.832Z","comments":true,"path":"2019/03/29/页面布局/页面布局demo/1.4去除列表最后一个li元素的border-bottom/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/页面布局demo/1.4去除列表最后一个li元素的border-bottom/","excerpt":"","text":"1.4去除列表最后一个li元素的border-bottom *{ margin:0; padding:0; } .div{ width:200px; border:5px solid red; margin:20px 0 0 20px; } .div ul li{ list-style-type:none; height:26px; line-height:26px; border-bottom:1px dashed lightblue; } /*方式一： .div ul li.lastLi{ margin-bottom:-1px; }*/ .div ul{ overflow:hidden; } Item A Item B Item C Item D Item E","categories":[],"tags":[]},{"title":"","slug":"页面布局/页面布局demo/1.3负边距加定位实现水平垂直居中","date":"2019-03-29T02:31:27.463Z","updated":"2019-03-29T02:47:56.056Z","comments":true,"path":"2019/03/29/页面布局/页面布局demo/1.3负边距加定位实现水平垂直居中/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/页面布局demo/1.3负边距加定位实现水平垂直居中/","excerpt":"","text":"负边距加定位实现水平垂直居中 .div1{ width:200px; height:200px; position:relative; border: 1px solid red; } .div2{ width:100px; height:100px; background:pink; position: absolute; /*left/top:子盒子相对父盒子的一半，此时在右下角*/ left: 50%; top:50%; /*transform：相对自身元素走自己盒子的一半*/ transform: translate(-50%,-50%); }","categories":[],"tags":[]},{"title":"","slug":"页面布局/页面布局demo/1.2去除列表右边框","date":"2019-03-29T02:15:12.594Z","updated":"2019-03-29T02:30:04.200Z","comments":true,"path":"2019/03/29/页面布局/页面布局demo/1.2去除列表右边框/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/页面布局demo/1.2去除列表右边框/","excerpt":"","text":"去除列表右边框 *{ margin:0; padding:0; } .div1{ width:780px; height:380px; margin:0 auto; border:3px solid skyblue; overflow:hidden; margin-top:10px; } .div1 ul{ margin-right:-20px; } .div1 ul li{ list-style-type:none; width:180px; height:180px; margin:0 20px 20px 0; float:left; background:pink; }","categories":[],"tags":[]},{"title":"","slug":"页面布局/页面布局demo/1.1负边距","date":"2019-03-29T02:01:32.072Z","updated":"2019-03-29T02:16:28.229Z","comments":true,"path":"2019/03/29/页面布局/页面布局demo/1.1负边距/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/页面布局demo/1.1负边距/","excerpt":"","text":"负边距--向上移动 *{ margin:0; padding:0; } .div{ width:100%; height:200px; } .div1{ height:100px; background:lightblue; width:100%; float:left; } .div2{ height:100px; background:pink; width:30%; float:left; /*margin-left:-29%;*/ /*margin-left:-30%;*/ margin-left:-100%; } div1 div2","categories":[],"tags":[]},{"title":"","slug":"页面布局/页面布局","date":"2019-03-29T01:45:09.835Z","updated":"2019-03-29T08:32:09.118Z","comments":true,"path":"2019/03/29/页面布局/页面布局/","link":"","permalink":"http://yoursite.com/2019/03/29/页面布局/页面布局/","excerpt":"","text":"@[页面布局] 1.负边距与浮动布局1.1负边距所谓的负边距就是margin取负值的情况，如margin:-100px，margin:-100%。当一个元素与另一个元素margin取负值时将拉近距离。常见的功能如下：向上移动当多个元素同时从标准流中脱离开来时，如果前一个元素的宽度为100%宽度，后面的元素通过负边距可以实现上移。当负的边距超过自身的宽度将上移，只要没有超过自身宽度就不会上移。margin-left:-30%时运行效果： margin-left:-100%时运行效果： margin-left:-29%时运行效果： 去除列表有边框下面的效果中右边多出了20px的距离，底下多出20px空白： 解决： 负边距+定位实现水平垂直居中 去除列表最后一个li元素的border-bottom 底部最后1px问题： 解决： 2.三栏式布局2.1 圣杯布局布局要求： 三列布局，中间宽度自适应，两边定宽； 中间栏要在浏览器中优先展示渲染； 允许任意列的高度最高； 要求只用一个额外的DIV标签； 要求用最简单的CSS、最少的HACK语句；详情见另一篇博客《三栏布局》 附上代码: &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>圣杯布局&lt;/title> &lt;style type=\"text/css\"> *{margin: 0;padding: 0;} body{min-width: 700px;} .header, .footer{ border: 1px solid #333; background: #aaa; text-align: center; } .left, .main, .right{ position: relative; float: left; min-height: 130px; } .container{ border: 2px solid yellow; padding:0 220px 0 200px; overflow: hidden; } .left{ margin-left: -100%; left: -200px; width: 200px; background: red; } .right{ margin-left: -220px; right: -220px; width: 220px; background: green; } .main{ width: 100%; background: blue; } .footer{ clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"header\">header&lt;/div> &lt;div class=\"container\"> &lt;div class=\"main\">main&lt;/div> &lt;div class=\"left\">left&lt;/div> &lt;div class=\"right\">right&lt;/div> &lt;/div> &lt;div class=\"footer\">footer&lt;/div> &lt;/body> &lt;/html> 3.弹性布局4.流式布局5.瀑布流布局7.响应式布局8.REM实现响应式布局你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法^1 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: Alt 带尺寸的图片: =30x30 居中的图片: Alt 居中并且带尺寸的图片: =30x30 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片. // An highlighted block var foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图： flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","categories":[],"tags":[]},{"title":"","slug":"Ajax","date":"2019-03-25T13:57:40.771Z","updated":"2019-03-21T12:48:03.766Z","comments":true,"path":"2019/03/25/Ajax/","link":"","permalink":"http://yoursite.com/2019/03/25/Ajax/","excerpt":"","text":"@TOC Ajax学习1.原生Ajax// 使用Ajax发送请求需要如下几步： //1.创建XMLHttpRequest对象 var xhr = new XMLHttpRequest; //2.准备发送 xhr.open('get','./01.check.php?username='+uname+'&amp;password='+pw,true); //3.执行发送动作 xhr.send(null); //4.指定回调函数 xhr.onreadstatechane = function(){ if(xhr.readState == 4){ if(xhr.status == 200){ var data = xhr.responseText; var info = document.getElementById('info'); if(data == '1'){ info.innerHTML = '登录成功'; }else if(data == '2'){ info.innerHTML = '用户名或者密码错误'; } } } } 1.创建XMLHttpRequest对象 var xhr = null; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest();//标准 }else{ xhr = new ActiveObject(\"Microsoft\");//IE6 } 2. 准备发送 参数一：请求方式(get获取数据，post提交数据) 参数二：请求地址 参数三：同步或异步标志位，默认true表示异步，false表示同步 如果是get请求那么请求参数必须在url中传递，encodeURI()用来对中文参数进行编码，防止乱码 var param = 'username'+uname+'&amp;password='+pw; xhr.open('get','03get.php?'+encodeURI(param),true); 3. 执行发送动作get请求在这里需要添加null参数，null不能省 xhr.send(null); post请求参数通过send传递，不需要通过encodeURI()转码 xhr.open('post','04post.php',false); 4. 指定回调函数 readState=1表示已经发送了请求 readState=2表示浏览器已经接收到了服务器响应的数据 readState=3表示正在解析数据 readState=4表示数据已经解析完成，可以使用了，但是这个数据不一定是正常的 HTTP常见的状态码： 200：响应成功 404：没有找到请求的资源 500：服务器端错误 2.Jsonjson数据和普通js对象的区别： json数据没有变量 json行驶的数据结尾没有分号 json数据中的链必须用双引号包住 var str = '{\"name\":\"zahngsan\",\"age\":\"12\"}'; var obj = JSON.parse(str);//把json行驶的字符串转换成对象 var str1 = JSON.stringify(obj);//把对象转成字符串 window.onload = function() { var btn = document.getElementById('btn'); btn.onclick = function(){ var uname = document.getElementById('username').value; var pw = document.getElementById('password').value; //1.创建XMLHttpRequest对象 var xhr = null; if(window.XMLHttpRequest){ xhr = XMLHttpRequest(); }else{ xhr = ActiveObject('Microsoft'); } //2.准备发送 var param = 'username='+uname+'&amp;password='+pw; xhr.open('post','07.php',true); //3.执行发送动作 xhr.setRequestHeader('Content-Type',\"application/x-www-form-urlencoded\"); xhr.send(param);//post在这里传递，不需要转码 //4.指定回调函数 xhr.onreadstatechange = function(){ if(xhr.readState == 4){ if(xhr.status == 200){ var data = xhr.responseText; var obj = JSON.parse(data); var tag = '&lt;div>&lt;span>'+obj.info+'&lt;/span>&lt;span>-----&lt;/span>&lt;span>'+obj.message+'&lt;/span>&lt;/div>'; var info = document.getElementById('info'); info.innerHTML = tag; console.log(2); //console.log(data.name1); //console.log(data.name2); } } } console.log(3); } } 封装Ajaxfunction ajax(url,type,param,dataType,callback){ var xhr = null; if(window.XHRHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject('Microsoft.XMLHTTP'); } if(type == 'get'){ url += \"?\"+param; } xhr.open(type,url,true); var data = null; if(type == 'post'){ if(type == 'post'){ data = param; xhr.setRequestHeader('Ccontent-Type',\"application/x-www-form-urlencoded\"); } xhr.send(data); xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ var data = xhr.responseText; if(dataType == 'json'){ data = JSON.parse(data); } callback(data); } } } } } function ajax(obj){ // 默认参数 var defaults = { type : 'get', data : {}, url : '#', dataType : 'text', async : true, success : function(data){console.log(data)} } // 处理形参，传递参数的时候就覆盖默认参数，不传递就使用默认参数 for(var key in obj){ defaults[key] = obj[key]; } // 1、创建XMLHttpRequest对象 var xhr = null; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject('Microsoft.XMLHTTP'); } // 把对象形式的参数转化为字符串形式的参数 /* {username:'zhangsan','password':123} 转换为 username=zhangsan&amp;password=123 */ var param = ''; for(var attr in obj.data){ param += attr + '=' + obj.data[attr] + '&amp;'; } if(param){ param = param.substring(0,param.length - 1); } // 处理get请求参数并且处理中文乱码问题 if(defaults.type == 'get'){ defaults.url += '?' + encodeURI(param); } // 2、准备发送（设置发送的参数） xhr.open(defaults.type,defaults.url,defaults.async); // 处理post请求参数并且设置请求头信息（必须设置） var data = null; if(defaults.type == 'post'){ data = param; xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); } // 3、执行发送动作 xhr.send(data); // 处理同步请求，不会调用回调函数 if(!defaults.async){ if(defaults.dataType == 'json'){ return JSON.parse(xhr.responseText); }else{ return xhr.responseText; } } // 4、指定回调函数（处理服务器响应数据） xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ var data = xhr.responseText; if(defaults.dataType == 'json'){ // data = eval(\"(\"+ data +\")\"); data = JSON.parse(data); } defaults.success(data); } } } } 调用： window.onload = function(){ var btn1 = document.getElementById('btn1'); btn1.onclick = function(){ ajax('./10-1.php','get','username=李四&amp;password=123','text',function(data){ var div1 = document.getElementById('info1'); div1.innerHTML = data; }); } var btn2 = document.getElementById('btn2'); btn2.onclick = function(){ ajax('./10-2.php','post','username=张三&amp;password=123456','json',function(data){ var div2 = document.getElementById('info2'); // div2.innerHTML = data; div2.innerHTML = data.username + \"=====\" + data.password; }); } } jQuer-Ajax相关的API基本使用window.onload = function(){ var btn = document.getElementById('btn'); btn.onclick = function(){ var code = document.getElementById('code').value; $.ajax({ type:'post', url:'./11.php', data:{code:code}, dataType:'json', success:function(data){ /*var info = document.getElementByid('info'); if(data.flag == 0){ info.innerHTML = \"没有这本书\"; }else{ var tag = '&lt;ul>&lt;li>书名：' + data.bookname + '&lt;/li>&lt;li>作者：' + data.author + '&lt;/li>&lt;li>描述：' + data.desc + '&lt;/li>&lt;/ul>'; info.innerHTML = tag;*/ if(data.flag == 0){ $('#info').html(\"该图书不存在\"); }else{ var tag = '&lt;ul>&lt;li>书名：' + data.bookname + '&lt;/li>&lt;li>作者：' + data.author + '&lt;/li>&lt;li>描述：' + data.desc + '&lt;/li>&lt;/ul>'; $(\"#info\").html(tag); } }, error:function(data){ console.log(data); $(\"#info\").html(\"服务器发生错误，请与管理员联系\"); } } }) } } 精简： var data = ajax({ type:'post', url:'./14.php', dataType:'json', async:false, //data:{username:\"张三\",password:\"123\"} data:{code:code} }); /*console.log(data); var html = '&lt;div>&lt;span>用户名：'+data.password+'&lt;/span>&lt;span>密码：'+data.password+'&lt;/span>&lt;/div>' $(\"#info\").html(html);*/ data = data.responseJSON; if(data.flag == 0){ $(\"#info\").html(\"该图书不存在\"); }else{ var tag = '&lt;ul>&lt;li>书名：' + data.bookname + '&lt;/li>&lt;li>作者：' + data.author + '&lt;/li>&lt;li>描述：' + data.desc + '&lt;/li>&lt;/ul>'; $(\"#info\").html(tag); }","categories":[],"tags":[]},{"title":"水平垂直居中","slug":"水平垂直居中","date":"2019-03-25T13:57:40.491Z","updated":"2019-04-03T01:04:11.897Z","comments":true,"path":"2019/03/25/水平垂直居中/","link":"","permalink":"http://yoursite.com/2019/03/25/水平垂直居中/","excerpt":"","text":"文字水平垂直居中一行文字的水平垂直居中对齐方式&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;1-水平垂直居中&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{ height: 200px; width: 200px; border: 1px solid #333; text-align: center;/*块级元素内文本的水平对齐方式*/ } span{ line-height: 200px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;span&gt;一行文本水平居中显示&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 显示结果: 一行文字水平居中显示 块级元素水平垂直居中显示方法一：absolute+transform&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;2-块级元素水平垂直居中-absolute+transform&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent{ width: 400px; height: 400px; border:1px solid #ccc; position: relative; } .child{ width: 200px; height: 200px; border: 1px solid #333; position: absolute; left: 50%; top:50%; transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); /* IE 9 */ -webkit-transform: translate(-50%,-50%); /* Safari and Chrome */ -o-transform: translate(-50%,-50%); /* Opera */ -moz-transform: translate(-50%,-50%); /* Firefox */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 多行文字水平垂直居中显示 &lt;br&gt;使用absolute+transform方法 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 解释：绝对定位元素的定位基准点是其有定位元素的祖先元素而translate要做偏移，是相对于自身的中心点而言，如果用百分比做单位，参考值就是本身元素的宽度 如图： 绝对定位 transform 效果： 块级元素水平垂直方法二：综合水平居中和垂直居中&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;综合水平居中和垂直居中&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent{ width: 400px; height: 400px; border:1px solid #ccc; text-align: center; display:table-cell; vertical-align: middle; } .child{ width: 200px; height: 200px; border:1px solid #ccc; display: inline-block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果： 一个相关的例子，解决图片底部3px的问题。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;综合水平居中和垂直居中&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent{ width: 400px; height: 400px; /*border:1px solid #ccc;*/ background-color: red; text-align: center; display:table-cell; vertical-align: middle; } img{ width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;img src=&quot;./img/1.jpg&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 问题：父框会多出3px的高度 多出3px 解决： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;综合水平居中和垂直居中&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent{ width: 400px; height: 400px; /*border:1px solid #ccc;*/ background-color: red; text-align: center; display:table-cell; vertical-align: middle; /*解决方法一：*/ /*font-size: 0px;*/ /*解决方法二：*/ /*line-height:0px;*/ } img{ width: 100%; height: 100%; /*解决方法二：给img设置display:block;使vertical-align:middle失效，因为它对块级元素不生效*/ display: block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;img src=&quot;./img/1.jpg&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果： 解决了3px 块级元素水平垂直方法三：flex方法&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;4-flex方法&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent{ height: 400px; width: 400px; border:1px solid #ccc; display: flex; justify-content: center; align-items:center; } .child{ height: 200px; width: 200px; border:1px solid #ccc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果：","categories":[],"tags":[]},{"title":"","slug":"三次握手和四次挥手过程","date":"2019-03-25T13:57:40.485Z","updated":"2019-03-19T08:55:49.424Z","comments":true,"path":"2019/03/25/三次握手和四次挥手过程/","link":"","permalink":"http://yoursite.com/2019/03/25/三次握手和四次挥手过程/","excerpt":"","text":"三次握手（1）三次握手的详述 首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 三次握手建立TCP连接 最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。（A、B关闭状态CLOSED——B收听状态LISTEN——A同步已发送状态SYN-SENT——B同步收到状态SYN-RCVD——A、B连接已建立状态ESTABLISHED） B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应。 1）第一次握手：A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，（首部的同步位SYN=1，初始序号seq=x），（SYN=1的报文段不能携带数据）但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。 2）第二次握手：B收到连接请求报文段后，如同意建立连接，则向A发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态； 3）第三次握手：TCP客户进程收到B的确认后，要向B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）。 当B收到A的确认后，也进入ESTABLISHED状态。 （2）总结三次握手过程： 第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认； 第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量； 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。 起初A和B都处于CLOSED状态——B创建TCB，处于LISTEN状态，等待A请求——A创建TCB，发送连接请求（SYN=1，seq=x），进入SYN-SENT状态——B收到连接请求，向A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入SYN-RCVD状态——A收到B的确认后，给B发出确认（ACK=1，ack=y+1，seq=x+1），A进入ESTABLISHED状态——B收到A的确认后，进入ESTABLISHED状态。 TCB传输控制块Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。 （3）为什么A还要发送一次确认呢？可以二次握手吗？ 答：主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。 （4）Server端易受到SYN攻击？ 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。 防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。 四次挥手假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ TCP连接释放的过程 数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（A、B连接建立状态ESTABLISHED——A终止等待1状态FIN-WAIT-1——B关闭等待状态CLOSE-WAIT——A终止等待2状态FIN-WAIT-2——B最后确认状态LAST-ACK——A时间等待状态TIME-WAIT——B、A关闭状态CLOSED） 1）A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。 2）B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。 3）A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。 4）B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。 5）A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。 （2）总结四次挥手过程： 起初A和B处于ESTABLISHED状态——A发出连接释放报文段并处于FIN-WAIT-1状态——B发出确认报文段且进入CLOSE-WAIT状态——A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态——A发出确认报文段且进入TIME-WAIT状态——B收到确认报文段后进入CLOSED状态——A经过等待计时器时间2MSL后，进入CLOSED状态。 （3）为什么A在TIME-WAIT状态必须等待2MSL的时间？ MSL最长报文段寿命Maximum Segment Lifetime，MSL=2 答： 两个理由：1）保证A发送的最后一个ACK报文段能够到达B。2）防止“已失效的连接请求报文段”出现在本连接中。 1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。 2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 （4）为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 （5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。","categories":[],"tags":[]},{"title":"","slug":"缓存机制","date":"2019-03-25T13:57:40.471Z","updated":"2019-03-19T09:09:17.300Z","comments":true,"path":"2019/03/25/缓存机制/","link":"","permalink":"http://yoursite.com/2019/03/25/缓存机制/","excerpt":"","text":"# HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。 浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。 报文信息主要分为两部分 1.包含属性的首部(header)--------------------------附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 2.包含数据的主体部分(body)-----------------------HTTP请求真正想要传输的部分 #缓存规则解析 为方便大家理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。 在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。 第一次请求 HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。 已存在缓存数据时，仅基于强制缓存，请求数据的流程如下 强缓存 对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。 我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 #强制缓存 从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。 对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 例子 Expires Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886） 举个板栗 图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 #对比缓存 对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 对比缓存例子 通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。 对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。","categories":[],"tags":[]},{"title":"","slug":"盒模型","date":"2019-03-25T13:57:40.452Z","updated":"2019-03-19T12:37:11.955Z","comments":true,"path":"2019/03/25/盒模型/","link":"","permalink":"http://yoursite.com/2019/03/25/盒模型/","excerpt":"","text":"@TOC 盒模型概念所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 （1）CSS盒模型和IE盒模型的区别： 1. 在标准盒模型中，width和height指的是内容区域和高度。增加内边距和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 2. IE盒模型中，width和height指的是内容区域+border+padding的宽度和高度。 IE盒模型 （2）CSS如何设置这两种模型 /*设置当前盒子为 标准模型(默认)*/ box-sizing:content-box; /*设置当前盒子为 IE模型*/ box-sizing:border-box; （3）JS如何设置，获取盒模型对应的宽和高 /*方式一：通过DOM节点的style样式获取*/ element.style.width/height; 缺点：通过这种方式，只能获得行内样式，不能获得内嵌样式和外链样式 /*方式二：IE独有*/ element.currentStyle.width/height; 可以获取（三种css样式都可以）。但是这种方式只有IE独有。 /*方式三：通用型*/ window.getComputedStyle(element).width/height; 可兼容Chrome，firefox浏览器 /*方式四：*/ element.getBoundingClientRect().width/height; 此API的作用：获取一个元素的绝对位置。绝对位置是视窗viewport左上角的绝对位置。此API可以拿到四个属性：left,top,width,height. (4)margin塌陷/margin重叠问题 标准文档流汇总，竖直方向的margin不重叠，只取较大的值作为margin（水平方向的margin是可以叠加的，即水平方向没有塌陷现象） 父子布局： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding:0; } .father{ background-color: green; } .son{ height: 100px; width: 100px; margin-top:10px; background-color: skyblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; son son的height是100px,margin-top是10px，结果height是100px;fatherdheight是100px,而不是110px，因为son和father在竖直方向上公用一个matgin-top. 技巧：善用父亲的padding,而不是儿子的margin. 父亲margin的问题 border解决问题 兄弟布局： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div1{ height: 100px; width: 100px; background-color: green; margin-bottom: 50px; } .div2{ height: 100px; width: 100px; background-color: skyblue; margin-bottom: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; div1,div2的宽高一致，都是100100，div1的margin-bottom为50px，div2的margin-bottom为30px，body的大小为2501333。所以，竖直方向的margin不叠加，以较大的为准。 #BFC解决外边距重叠 BFC:块级格式化上下文。可以理解为一个独立的区域。BFC的原理： BFC里面的元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。 BFC区域不与旁边的float box区域重叠， 计算BFC的高度时，浮动的子元素也参与计算。 如何生成BFC 方式一：overflow:不为visible,可以让属性是hidden,auto. 方式二：浮动中：float的属性不为none.意思是只要创建了浮动，当前元素就创建了BFC. 方式三：定位中：只要position的值不是static或relative即可。可以是absolute或fixed，也就生成了FC. 方式四：display为inline-block,table-cell,table-caption,flex,inline-flex 边框 border : border-width || border-style || border-color 定位displayIFC和BFC的问题","categories":[],"tags":[]},{"title":"","slug":"浮动与定位","date":"2019-03-25T13:57:40.436Z","updated":"2019-03-19T13:26:27.971Z","comments":true,"path":"2019/03/25/浮动与定位/","link":"","permalink":"http://yoursite.com/2019/03/25/浮动与定位/","excerpt":"","text":"浮动(float) 普通流(normal flow) CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动 浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 浮动 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 选择器{float:属性值;} | 属性值 | 描述 | | ----- | ---------- | | left | 元素向左浮动 | | right | 元素向右浮动 | | none | 元素不浮动（默认值） | 浮动详细内幕特性浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 浮动首先创建包含块的概念（包裹）。就是说，浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮动的目的就是为了让多个块级元素同一行上显示。 float 浮 漏 特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。 漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。 特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML结构 。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 清除浮动为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 准确地说，并不是清除浮动，而是清除浮动后造成的影响 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 选择器{clear:属性值;} | 属性值 | 描述 | | ----- | --------------------- | | left | 不允许左侧有浮动元素（清除左侧浮动的影响） | | right | 不允许右侧有浮动元素（清除右侧浮动的影响） | | both | 同时清除左右两侧浮动的影响 | 方法一：额外标签法html 是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 方法二：父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） css 可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 方法三：使用after伪元素清除浮动:after 方式为空元素的升级版，好处是不用单独加标签了 使用方法： css .clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 方法四：使用before和after双伪元素清除浮动使用方法： css .clearfix:before,.clearfix:after { content:&quot;&quot;; display:table; /* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */ } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 | 边偏移属性 | 描述 | | ------ | ----------------------- | | top | 顶端偏移量，定义元素相对于其父元素上边线的距离 | | bottom | 底部偏移量，定义元素相对于其父元素下边线的距离 | | left | 左侧偏移量，定义元素相对于其父元素左边线的距离 | | right | 右侧偏移量，定义元素相对于其父元素右边线的距离 | 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 | 值 | 描述 | | -------- | ------------------------ | | static | 自动定位（默认定位方式） | | relative | 相对定位，相对于其原文档流的位置进行定位 | | absolute | 绝对定位，相对于其上一个已经定位的父元素进行定位 | | fixed | 固定定位，相对于浏览器窗口进行定位 | 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 相对定位relative(自恋型)相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。 绝对定位absolute (拼爹型)[注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的盒子没有边偏移如果只是给盒子指定了 定位，但是没有给与边偏移，则改盒子以标准流来显示排序，和上一个盒子的底边对齐，但是不占有位置。 子绝父相这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 1. 固定定位的元素跟父亲没有任何关系，只认浏览器。 2. 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： 1. z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 2. 如果取值相同，则根据书写顺序，后来居上。 3. 后面数字一定不能加单位。 4. 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结| 定位模式 | 是否脱标占有位置 | 是否可以使用边偏移 | 移动位置基准 | | ------------ | ---------- | --------- | ----------- | | 静态static | 不脱标，正常模式 | 不可以 | 正常模式 | | 相对定位relative | 不脱标，占有位置 | 可以 | 相对自身位置移动 | | 绝对定位absolute | 完全脱标，不占有位置 | 可以 | 相对于定位父级移动位置 | | 固定定位fixed | 完全脱标，不占有位置 | 可以 | 相对于浏览器移动位置 | 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后，可以不用转换模式，直接给高度和宽度就可以了。","categories":[],"tags":[]},{"title":"WEB API","slug":"Web API","date":"2019-03-25T13:57:40.428Z","updated":"2019-03-18T08:52:59.925Z","comments":true,"path":"2019/03/25/Web API/","link":"","permalink":"http://yoursite.com/2019/03/25/Web API/","excerpt":"","text":"DOM树核心DOM和HTML DOM 核心DOM：操作一切结构化文档的统一API 特点：繁琐！万能！ HTML DOM:专门操作HTML文档的简化版DOM API 特点：简洁，不是万能！ 节点对象：Node 三大属性：nodeType、nodeName、nodeValue DOM:查找方式一：不要查找直接获得元素 html document.documentElement head document.head body document.body 方式二：按节点间关系查找 1.父子关系 elem.parentNode 获得elem的父节点 elem.childNodes 获得elem的所有**直接**子节点 elem.firstChild 获得elem下的第一个子节点 elem.lastChild 获得elem下的最后一个子节点 2.兄弟节点 elem.previousSibling 获得elem的前一个兄弟节点 elem.nextSibling 获得elem的后一个兄弟节点 存在的问题： 一切文本都是节点对象，包括看不见的空字符（tab,空格，换行） 解决：元素树 方式三：元素树 1.父子关系 elem.parentElement 获得elem的父元素 elem.children 获得elem的所有**直接**子元素 elem.firstElementChild 获取elem下的第一个子元素 elem.lastElementChild 获得elem下的最后一个子元素 2.兄弟关系 elem.previousElementSibling 获得elem的前一个兄弟元素 elem.nextElementSibling 获得elem的后一个兄弟元素 元素树不是一颗新树，只是节点树的一个子集 存在问题： 只适合IE9+的浏览器 children和childNodes只能查找直接子节点，无法查找更深层次 解决： 1.递归遍历 缺点：反复访问集合，导致反复查找DOM树，效率低 解决2：节点迭代器 方法四：按HTML查找 1.按id查找 var elem = document.getElementById(&quot;ID名&quot;); 2.按标签名查找 var elems = parent.getElementsByTagName(&quot;标签名&quot;); 可查找所有后代元素 3.按name属性查找 var elems = document.getElementsByName(&quot;name&quot;); 4.按class属性查找 var elems = parent.getElementsByClassName(&quot;class&quot;); 适用于：一个元素被多个class修饰。在所有后代中查找 问题：每次只能按一种条件查找，当查找条件复杂时，步骤就非常繁琐。 解决：用选择器查找 1.仅查找一个元素 var elem = parent.querySelector(&quot;选择器&quot;); 2.查找多个元素 var elems = parent.querySelectorAll(&quot;选择器&quot;); 返回非动态集合。但是存在浏览器兼容性的问题。 非动态集合：实际存储完整数据，即使反复访问集合，也不会反复查找DOM树 DOM:修改修改分为修改内容，属性，样式三种。 1.内容 - 获取或修改元素的HTML代码片段内容 elem.innerHTML -2.获取或修改元素的纯文文本内容 elem.textContent(与innerHTML相比，去掉了内嵌标签，将转义字符翻译为原文) -获取或修改表单元素的值 elem.value 2.属性 - 核心DOM: 属性节点都保存在elem的attributes集合中 var node = elem.attributes[&quot;属性名&quot;]; var value = node.nodeValue; 获取：var value = elem.getAttribute(&quot;属性名&quot;); 修改：elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;); 移除：elem.removeAttribute(&quot;属性名&quot;); 判断有没有：var bool = elem.hasAttribute(&quot;属性名&quot;); 可以直接使用：class - HTML DOM: 获取：elem.属性名 修改：elem.属性名=值 移除：elem.属性名 = &quot;&quot; 判断有没有：elem.属性名！==&quot;&quot; .className ===》 就是HTML中的class 状态属性：disabled selected checked 特点：值是bool类型 不能用核心DOM类型，只能用HTML DOM类型 - 自定义扩展属性： 定义：data-属性名=&quot;值&quot; 获取：核心DOM HTML5:elem.dataset.属性名 只要标识多个元素，且不希望人为或是被程序修改 只要给元素添加行为时，查找元素都用自定义扩展属性 - 样式 1.内联样式 特点：优先级最高，当前元素独有 - 修改一个内联样式 elem.style.css属性 = 值 所有css属性要去横线变驼峰 -批量替换内联样式 elem.style.cssText =&quot;&quot;; 2.获得计算后的样式(最终应用到当前元素上的所有样式的合集，一个元素的完整样式，可能来源多个地方) //获得计算后的style对象 var style = getComputedStyle(elem); //获得style中的css属性值 var value = style.css属性 3.修改样式中的样式： //获得样式表对象 var sheet = document.styleSheets[i]; //获得样式表对象中的一套规则： var rule = sheet.cssRules[i]; //修改样式 var style = rule.style; style.css属性 = 值 DOM:添加和删除//1.创建空元素 var a = document.creatElement(&quot;a&quot;); //设置关键属性 a.href = &quot;http://baidu.com&quot;; a.innerHTML=&quot;go to baidu&quot;; //3.将新元素添加到DOM树 末尾追加：parent.appendChild(a); 中间插入：parent.insertBefore(a,child); 替换：parent.replace(a,child); 总结：尽量减少操作DOM树的次数 每次操作DOM树都会导致重新layout ![layout](https://i.imgur.com/htVxk7k.jpg) 只要修改DOM树(修改样式，修改位置，添加删除元素等)都会导致重新layout---效率低 解决：如果同时添加父元素和子元素，都要先在内存中将子元素，添加到父元素中，最后再将父元素，一次性添加到DOM树。 或是父元素已经在DOM树上了，要同时添加多个平级子元素时： 文档片段：内存中，临时存储一课DOM子树段的存储空间 //创建文档片段对象 var frag = document.creatDocumentFragment(); //先将子元素添加到DOM树指定父元素下 frag.appendChild(child); //将文档片段一次性添加到DOM树指定父元素下 parent.appendChild(frag); frag将子元素送到DOM树后，自动释放。 HTML DOM常用对象: 什么是: 对常用的元素，提供了简化版的API 优: 简化 缺: 不是万能 Image: 创建: var img=new Image(); Select: 属性: .selectedIndex 快速获得当前选中项的下标位置 .value 当选中项有value属性时，会返回option的value 如果选中项没有value属性，则用内容代替 .options: 获得select下所有option元素对象的集合 options.length 获得选项的个数 .length =&gt; .options.length 固定套路: 清空所有option sel.innerHTML=&quot;&quot;; sel.length=0; =&gt;sel.options.length=0; 方法: add(option) 代替 appendChild(option) 问题: 不支持frag remove(i) 移除i位置的option Option: 创建: var opt=new Option(text,value); 属性: .index .text .value table:管着行分组: 创建: var thead=table.createTHead() var tbody=table.createTBody(); var tfoot=table.createTFoot(); 删除: table.deleteTHead() table.deleteTFoot() 获取: tabel.tHead table.tFoot table.tBodies[i] 行分组:管着行: 创建: var tr=行分组.insertRow(i) 固定套路: 1. 在结尾追加一行: 行分组.insertRow() 2. 在开头插入一行: 行分组.insertRow(0) 删除: 行分组.deleteRow(i) 强调: 主语是行分组时，i要求是在行分组内的相对下标位置 获取: 行分组.rows 获得行分组内所有行的集合 行:管着格: 创建: var td=tr.insertCell(i) 固定套路: 末尾追加: tr.insertCell() 删除: tr.deleteCell(i) 获取: tr.cells form: 获取: var form=document.forms[i/id/name]; 属性: form.elements 获得表单中所有表单元素的值 强调: 表单元素包括: input select textarea button form.elements.length 获得表单中表单元素的个数 form.length==&gt; form.elements.length 固定套路: 获得结尾的按钮: var btn=form.elements[form.length-n] 方法: form.submit() //在程序中手动提交表单 表单元素: 获取: var 表单元素= form.elements[i/id/name] 如果表单元素有name属性，则: form.name属性值 方法: elem.focus() 让当前表单获得焦点 elem.blur()","categories":[],"tags":[]},{"title":"","slug":"剑指offer(1-6)","date":"2019-03-25T13:16:05.677Z","updated":"2019-03-25T13:15:07.492Z","comments":true,"path":"2019/03/25/剑指offer(1-6)/","link":"","permalink":"http://yoursite.com/2019/03/25/剑指offer(1-6)/","excerpt":"","text":"@剑指offer 1. 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路 [ [1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7] ] 根据这个数组的特点，可以发现： （1）每一行，从左到右递增 （2）每一列，从上到下递增 那么，我们在选择第一个数与target比较大小，第一个数的选取一定要选择数组中每行每列最后一个数。在这里我选取的是右上角的数和target比较。 (a)如果array[row,col]&gt;target，则向左走，即j– (b)如果array[row,col]&lt;target，则向右走，即i++ 参考代码如下： function Find(target, array) { // write code here var row = 0; var col = array[row].length-1; while(row&lt;=array.length-1&amp;&amp;col>=0){ if(target == array[row][col]) return true else if(target&lt;array[row][col]) col--; else row++ } } var arr = [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]]; console.log(Find(7,arr));//true 2.替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题目说的不太严谨： 1.能不能允许连续出现多个空格？ 2.若有可能连续多个空格，用多个还是单个20%进行替换？ 分三种情况解答:1.不会出现连续多个空格：直接用空格将字符串切割成数组，在用20%进行连接。 function replaceSpace(str) { return str.split(' ').join('%20'); } 2.允许出现多个空格，每个空格均用一个20%替换：用正则表达式找到所有空格依次替换 function replaceSpace(str) { return str.replace(/\\s/g,'%20'); } 3.允许出现多个空格，多个空格用一个20%替换：用正则表达式找到连续空格进行替换 function replaceSpace(str) { return str.replace(/\\s+/g,'%20'); } 方法二：利用split()+join() function replaceSpace(str) { // write code here // write code here let arr = str.split(' '); let newStr = arr.join('%20'); return newStr; } 3.从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 /*function ListNode(x){ this.val = x; this.next = null; }*/ function printListFromTailToHead(head) { // write code here var arr=[]; var me=head; while(me){ arr.push(me.val); me=me.next; } return arr.reverse(); } 方法二：unshift():在数组前添加任意项并返回新数组的长度 /*function ListNode(x){ this.val = x; this.next = null; }*/ function printListFromTailToHead(head) { var result=[]; while(head){ result.unshift(head.val); head=head.next; } return result; } 4.重建二叉树5.用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路： 1.整体思路是元素先依次进入栈1，再从栈1依次弹出到栈2，然后弹出栈2顶部的元素，整个过程就是一个队列的先进先出 2.但是在交换元素的时候需要判断两个栈的元素情况：“进队列时”，队列中是还还有元素，若有，说明栈2中的元素不为空，此时就先将栈2的元素倒回到栈1 中，保持在“进队列状态”。“出队列时”，将栈1的元素全部弹到栈2中，保持在“出队列状态”。所以要做的判断是，进时，栈2是否为空，不为空，则栈2元素倒回到栈1，出时，将栈1元素全部弹到栈2中，直到栈1为空。 var stack1=[],stack2=[]; function push(node) { // write code here stack1.push(node); } function pop() { // write code here if(stack2.length === 0){ if(stack1.length ===0){ return null; }else{ var len = stack1.length; for(var i=0;i&lt;len;i++){ stack2.push(stack1.pop()); } return stack2.pop(); } }else{ return stack2.pop(); } } 6.旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 剑指Offer中有这道题目的分析。这是一道二分查找的变形的题目。旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素 注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。 思路： （1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。但是如果不是旋转，第一个元素肯定小于最后一个元素。 （2）找到数组的中间元素。中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。 移动之后，第一个指针仍然位于前面的递增数组中。 中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。 移动之后，第二个指针仍然位于后面的递增数组中。 这样可以缩小寻找的范围。 （3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。 最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。 也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。 到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。 因此这一道题目比上一道题目多了些特殊情况： 我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。 这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。 第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。 也就无法移动指针来缩小查找的范围。 7.斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 function Fibonacci(n){ if(n&lt;=1){ return n; }else{ var f0=0,f1=1; for(var i=2;i&lt;=n;i++){ f2=f0+f1; f0=f1; f1=f2; } return f2;} }","categories":[],"tags":[]}]}